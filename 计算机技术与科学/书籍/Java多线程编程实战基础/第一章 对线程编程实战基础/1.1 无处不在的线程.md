1.1 无处不在的线程
示例代码
Java的代码总是又确定的线程运行的
``` java 
public class ThreadDemo {

    public static void main(String[] args) {
        // 获取当前线程名称
        System.out.println("currentThread Name is " + Thread.currentThread().getName());
        Helper helper = new Helper("Java Thread Anywhere");
        helper.run();
    }

    // 创建静态类Helper 继承自Runnable
    static class Helper implements Runnable {
        private final String message;

        Helper(String message) {
            this.message = message;
        }

        // 创建方法doSomething
        private void doSomething(String message) {
            // 输出当前线程名称
            System.out.println("do something in " + Thread.currentThread().getName());
            // 输出属性名称
            System.out.println("do something in " + message);
        }

        // 重写run方法
        @Override
        public void run() {
            // 调用内部方法
            this.doSomething(message);
        }
    }
}

```
1.2 线程的创建和运行
JVM会为Java代码分配两个调用栈（call stack）
- 1. java线程（Java线程）
- 2. 宿主机操作系统线程（native方法）