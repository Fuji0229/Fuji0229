1.接口参数校验
   入参出参校验，比如入参是否允许空，入参长度是否符合预期
2.修改老接口的兼容性问题
   当修改一个老接口时，尤其时这个接口需要对外提供服务时，需要兼容旧接口的访问方式
   ```java
   //老接口 
   void oldService(A,B){ 
   //兼容新接口，传个null代替C 
       newService(A,B,null); 
   } 
   //新接口，暂时不能删掉老接口，需要做兼容。 
   void newService(A,B,C){ 
       ...
    }
```
3.设计接口时，充分考虑接口的可扩展性
 要根据实际业务场景设计接口，充分考虑接口的可扩展性。

比如你接到一个需求：是用户添加或者修改员工时，需要刷脸。那你是反手提供一个员工管理的提交刷脸信息接口？还是先思考：提交刷脸是不是通用流程呢？比如转账或者一键贴现需要接入刷脸的话，你是否需要重新实现一个接口呢？还是当前按业务类型划分模块，复用这个接口就好，保留接口的可扩展性。

如果按模块划分的话，未来如果其他场景比如一键贴现接入刷脸的话，不用再搞一套新的接口，只需要新增枚举，然后复用刷脸通过流程接口，实现一键贴现刷脸的差异化即可。

![[Pasted image 20220912133506.png]]
4.接口考虑是否需要防重处理

   查询不是必须防重，更新 修改时，需要防重处理
   防重手段：
	1. Redis防重复，同一个请求方，一定时间间隔内的请求，是否进行过滤（并发不高时）可以使用数据防重表，以唯一流水号作为主键或者唯一索引
5.重点接口考虑线程池隔离
   登录 转账交易 下单等重要接口，不同的业务进行线程池隔离，避免某个业务的故障导致所有业务受到影响,重要业务重新分配线程池，多设置核心线程数保证业务正常运行
   ![[Pasted image 20220913083545.png]]
6.调用第三方接口的超时和异常处理
调用第三方的接口或者远程服务调用面临的基础问题
+ 异常
  访问三方接口超时，处理方式是重试、失败处理或者告警处理。
+ 超时
  设置连接的断开时间，避免三方接口的异常导致原接口长时间占用线程
+ 重试
  是否重试，重试的次数，根据实际业务做出调整。
7.接口实现考虑熔断和降级
服务雪崩: 某个基础服务不可用导致所有服务不可用
![[Pasted image 20220913084834.png]]
如果服务C出现问题，比如是**因为慢SQL导致调用缓慢**，那将导致B也会延迟，从而A也会延迟。堵住的A请求会消耗占用系统的线程、IO等资源。 当请求A的服务越来越多，占用计算机的资源也越来越多，最终会导致系统瓶颈出现，造成其他的请求同样不可用，最后导致业务系统崩溃。
最简单的方式是加开关：当下游服务出现问题时，开关降级，不再访问下游系统。
开源组件解决方案：Hystix
8.接口的关键代码，需要日志保驾护航
方法调用前：入参打印
接口调用后: 捕获异常
```java
public void transfer(TransferDTO transferDTO){
    log.info("invoke tranfer begin");
    //打印入参
    log.info("invoke tranfer,paramters:{}",transferDTO);
    try {
      res=  transferService.transfer(transferDTO);
    }catch(Exception e){
     log.error("transfer fail,account：{}",
     transferDTO.getAccount（）)
     log.error("transfer fail,exception:{}",e);
    }
    log.info("invoke tranfer end");
    }
```
9.接口的功能定义具备单一性
单一性是指接口做的事情比较单一，专一。登录接口，就只做检验账号用户名密码，返回用户ID。减少用户交互，把注册，一些配置查询等全部放到登录接口，就不太妥

10.接口有些场景,使用异步更合理

场景一：用户注册成功后发送邮件，邮件发送不能影响发送邮件
异步处理方案： 线程池或者消息队列
	![[Pasted image 20220913085745.png]]

场景二：用户发起批量转账
持久化成功就返回受理成功的信息，等到批量处理完成之后在返回给上游系统（这时用户就可以进行查账）
使用异步的作用：
	1.立即给调用方返回结果
	2.延迟给调用方的最终结果。在此期间可以做更多的额外操作（结果记录等）。
	3.执行过程中，可以释放占用的线程池等资源，避免阻塞，等到结果产生时再重新获取线程处理。
	4.异步流程可以等多次的调用结果出来后，一次性返回结果集合，提高响应效率。
11.优化接口耗时，远程串行改为远程并行调用
场景：APP首页，需要查询用户信息，查banner信息，弹窗信息。
![[Pasted image 20220913093500.png]]
![[Pasted image 20220913093511.png]]
解决：Java的异步编程利器 CompleteFuture

12.接口合并或者批处理思想
数据库查询或者远程调用时，能批量操作就不用for循环
```java
//反例
for(int i=0;i<n;i++){
  remoteSingleQuery(param)
}

//正例
remoteBatchQuery(param);
```
实例:kafka高效的原因-使用批处理提高服务端处理能力
13.接口实现过程中，适当应用缓存
**缓存场景**：读多写少时效性低的场景
**好处**：承载更多的请求，提高查询效率，减少数据库压力
例如平时改动比较少或者几乎不会变的商品信息，加入缓存后，请求过来之后，先查询缓存，如果缓存中未命中再查询数据库。
使用缓存带来的问题：
	缓存和数据库的数据一致性问题：缓存延时双删、删除重试机制、读取binlog异步删除缓存
	集群
	缓存击穿：设置数据永不过期
	缓存雪崩：Redis集群高可用，均匀设置过期时间
	缓存穿透：接口层校验，查询为空时设置个人默认空值标记、布隆过滤器
一般使用Redis分布式缓存，有时也可以考虑本地缓存比如Guava cache、Caffeine等。
本地缓存的缺点，无法进行大数据存储，应用进程的重启会使缓存失效。

14.接口考虑热点数据隔离
业务隔离：12306将热点数据分散处理，降低系统负载压力
系统隔离：比如系统分成了用户、商品、社区三个板块，分别使用不用的服务器、域名和数据库，做到从接入层到应用层再到数据层三层完全隔离
用户隔离：重点用户请求到配置更好的机器
数据隔离：使用单独的缓存集群或者数据库服务热点程序

15.可变参数配置化
场景：红包皮肤切换
错误案例：
	写死的配置
```java

if(duringChristmas){
   img = redPacketChristmasSkin;
}else if(duringSpringFestival){
   img =  redSpringFestivalSkin;
}

```
接口设计方案：
	实现红包皮肤的配合表，将红包皮肤做成配置化，抢红包的过期时间等，都可以搞到参数配置化表里面。（扩展化思想）

16.接口幂等性
用户的多次请求，消息队列的重复消费
幂等：
		计算机科学中，任意多次产生的影响均与一次执行产生的结果相同
实现方案：
+ select+insert+主键/唯一索引冲突
+ 直接insert+主键/唯一索引冲突
+ 状态机幂等
+ 抽取防重表
+ token令牌
+ 悲观锁
+ 乐观锁
+ 分布式锁

17.读写分离，优先考虑读从库，注意主从延迟问题
数据库的集群部署，既有主库也有从库，一般都是读写分离。主库写入，从库读取，对于读取实时性不高的数据时，考虑优先读取从库，分担主库的压力。此时就需要考虑主从延迟的问题。

18.接口确认返回的数据量，如果较大需要分页
一个接口返回报文，不应该包含过多的数据量，过多的数据量不仅处理复杂，数据传输的压力也会增大，数据量太大则进行拆分。如果是功能不相关的报文，应该考虑接口拆分。

19.好的接口实现，应该考虑SQL优化
SQL优化方向：
+ explain语句分析SQL查询计划，重点关注type、extra、filtered字段
+ show prifile分析，了解SQL执行的线程的状态以及消耗的时间
+ 索引优化（覆盖索引，最左匹配原则、隐式转换、order by以及group by的优化、join 优化）
+ 大分页问题优化（延迟关联、记录上一页最大id）
+ 数据量太大（分库分表、同步到es进行查询）

20.代码锁的粒度控制好
加锁粒度
	锁住的范围是多大
如果不涉及共享资源，没有上锁的必要。
案例：
	在业务代码中，有个Arraylist的操作涉及到多线程，需要加锁。有一段耗时的代码（slowNotShare方法）不涉及线程安全，如何设置锁？
错误
```java
	//不涉及共享资源的慢方法
private void slowNotShare() {
    try {
        TimeUnit.MILLISECONDS.sleep(100);
    } catch (InterruptedException e) {
    }
}

//错误的加锁方法
public int wrong() {
    long beginTime = System.currentTimeMillis();
    IntStream.rangeClosed(1, 10000).parallel().forEach(i -> {
        //加锁粒度太粗了，slowNotShare其实不涉及共享资源
        synchronized (this) {
            slowNotShare();
            data.add(i);
        }
    });
    log.info("cosume time:{}", System.currentTimeMillis() - beginTime);
    return data.size();
}
```
正确
```java
public int right() {
    long beginTime = System.currentTimeMillis();
    IntStream.rangeClosed(1, 10000).parallel().forEach(i -> {
        slowNotShare();//可以不加锁
        //只对List这部分加锁
        synchronized (data) {
            data.add(i);
        }
    });
    log.info("cosume time:{}", System.currentTimeMillis() - beginTime);
    return data.size();
}
```

21.接口状态和统一返回
提供必要的接口状态信息，比如一个转账接口是否调用成功，需要明确的告诉客户端。如果失败，具体的失败原因是什么。这些信息都必须要高速客户端，因此定义明确的错误码对应的描述。不要将后端的报错信息直接返回到客户端，对报错信息封装后返回。
![[Pasted image 20220913111009.png]]

22.接口考虑异常处理
异常处理的建议：
+ 尽量不要使用e.printStrackTrace()（可能会导致内存占满）,而是使用log进行打印
+ catch异常时，打印出具体的exception，利于更好的定位
+ 不要用一个exception捕捉所有的异常
+ 记得使用finally关闭流资源或者直接使用try-with-resource
+ 捕获异常和抛出异常必须匹配，或者捕获异常是抛出异常的父类
+ 捕获的异常，需要打日志
+ 注意异常对代码层次结构的侵染
+ 自定义封装异常，不要丢弃原始封装Trowable cause
+ 运行时异常RuntimeException，不应该通过catch的方式处理，而是预检查比如NullPointException处理
+ 注意异常匹配的顺序，优先捕获具体的异常

23.优化程序逻辑
复杂的业务代码，写清楚注释

