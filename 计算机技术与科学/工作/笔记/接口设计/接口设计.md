1.接口参数校验
   入参出参校验，比如入参是否允许空，入参长度是否符合预期
2.修改老接口的兼容性问题
   当修改一个老接口时，尤其时这个接口需要对外提供服务时，需要兼容旧接口的访问方式
   ```java
   //老接口 
   void oldService(A,B){ 
   //兼容新接口，传个null代替C 
       newService(A,B,null); 
   } 
   //新接口，暂时不能删掉老接口，需要做兼容。 
   void newService(A,B,C){ 
       ...
    }
```
3.设计接口时，充分考虑接口的可扩展性
 要根据实际业务场景设计接口，充分考虑接口的可扩展性。

比如你接到一个需求：是用户添加或者修改员工时，需要刷脸。那你是反手提供一个员工管理的提交刷脸信息接口？还是先思考：提交刷脸是不是通用流程呢？比如转账或者一键贴现需要接入刷脸的话，你是否需要重新实现一个接口呢？还是当前按业务类型划分模块，复用这个接口就好，保留接口的可扩展性。

如果按模块划分的话，未来如果其他场景比如一键贴现接入刷脸的话，不用再搞一套新的接口，只需要新增枚举，然后复用刷脸通过流程接口，实现一键贴现刷脸的差异化即可。

![[Pasted image 20220912133506.png]]
4.接口考虑是否需要防重处理
   接口幂等性
   查询不是必须防重，更新 修改时，需要防重处理
   防重手段：
	1. Redis防重复，同一个请求方，一定时间间隔内的请求，是否进行过滤（并发不高时）可以使用数据防重表，以唯一流水号作为主键或者唯一索引
5.重点接口考虑线程池隔离
   登录 转账交易 下单等重要接口，不同的业务进行线程池隔离，避免某个业务的故障导致所有业务受到影响,重要业务重新分配线程池，多设置核心线程数保证业务正常运行
   ![[Pasted image 20220913083545.png]]
6.调用第三方接口的超时和异常处理
调用第三方的接口或者远程服务调用面临的基础问题
+ 异常
  访问三方接口超时，处理方式是重试、失败处理或者告警处理。
+ 超时
  设置连接的断开时间，避免三方接口的异常导致原接口长时间占用线程
+ 重试
  是否重试，重试的次数，根据实际业务做出调整。
7.接口实现考虑熔断和降级
服务雪崩: 某个基础服务不可用导致所有服务不可用
![[Pasted image 20220913084834.png]]
如果服务C出现问题，比如是**因为慢SQL导致调用缓慢**，那将导致B也会延迟，从而A也会延迟。堵住的A请求会消耗占用系统的线程、IO等资源。 当请求A的服务越来越多，占用计算机的资源也越来越多，最终会导致系统瓶颈出现，造成其他的请求同样不可用，最后导致业务系统崩溃。
最简单的方式是加开关：当下游服务出现问题时，开关降级，不再访问下游系统。
开源组件解决方案：Hystix
8.接口的关键代码，需要日志保驾护航
方法调用前：入参打印
接口调用后: 捕获异常
```java
public void transfer(TransferDTO transferDTO){
    log.info("invoke tranfer begin");
    //打印入参
    log.info("invoke tranfer,paramters:{}",transferDTO);
    try {
      res=  transferService.transfer(transferDTO);
    }catch(Exception e){
     log.error("transfer fail,account：{}",
     transferDTO.getAccount（）)
     log.error("transfer fail,exception:{}",e);
    }
    log.info("invoke tranfer end");
    }
```
9.接口的功能定义具备单一性
单一性是指接口做的事情比较单一，专一。登录接口，就只做检验账号用户名密码，返回用户ID。减少用户交互，把注册，一些配置查询等全部放到登录接口，就不太妥

10.接口有些场景,使用异步更合理

场景一：用户注册成功后发送邮件，邮件发送不能影响发送邮件
异步处理方案： 线程池或者消息队列
	![[Pasted image 20220913085745.png]]

场景二：用户发起批量转账
持久化成功就返回受理成功的信息，等到批量处理完成之后在返回给上游系统（这时用户就可以进行查账）
使用异步的作用：
	1.立即给调用方返回结果
	2.延迟给调用方的最终结果。在此期间可以做更多的额外操作（结果记录等）。
	3.执行过程中，可以释放占用的线程池等资源，避免阻塞，等到结果产生时再重新获取线程处理。
	4.异步流程可以等多次的调用结果出来后，一次性返回结果集合，提高响应效率。
11.优化接口耗时，远程串行改为远程并行调用
场景：APP首页，需要查询用户信息，查banner信息，弹窗信息。
![[Pasted image 20220913093500.png]]
![[Pasted image 20220913093511.png]]
解决：Java的异步编程利器 CompleteFuture

12.接口合并或者批处理思想
数据库查询或者远程调用时，能批量操作就不用for循环
```java
//反例
for(int i=0;i<n;i++){
  remoteSingleQuery(param)
}

//正例
remoteBatchQuery(param);
```
实例:kafka高效的原因-使用批处理提高服务端处理能力
13.接口实现过程中，适当应用缓存
**缓存场景**：读多写少时效性低的场景
**好处**：承载更多的请求，提高查询效率，减少数据库压力
例如平时改动比较少或者几乎不会变的商品信息，加入缓存后，请求过来之后，先查询缓存，如果缓存中未命中再查询数据库。
使用缓存带来的问题：
	缓存和数据库的数据一致性问题：缓存延时双删、删除重试机制、读取binlog异步删除缓存
	集群
	缓存击穿：设置数据永不过期
	缓存雪崩：Redis集群高可用，均匀设置过期时间
	缓存穿透：接口层校验，查询为空时设置个人默认空值标记、布隆过滤器
一般使用Redis分布式缓存，有时也可以考虑本地缓存比如Guava cache、Caffeine等。
本地缓存的缺点，无法进行大数据存储，应用进程的重启会使缓存失效。

14.接口考虑热点数据隔离
业务隔离：12306将热点数据分散处理，降低系统负载压力
系统隔离：比如系统分成了用户、商品、社区三个板块，分别使用不用的服务器、域名和数据库，做到从接入层到应用层再到数据层三层完全隔离
用户隔离：
数据隔离：


