Spring Securtiy中的角色和权限
![[附件/Pasted image 20220916164955.png]]GrantedAuthority 对象代表的就是一种权限对象，而一个 UserDetails 对象具备 1 个或多个 GrantedAuthority 对象。通过这种关联关系可以对用户的权限进行限制

简单的权限控制
-   hasAuthority（String）：允许具有特定权限的用户访问。
-   hasAnyAuthority（String）：允许具有任一权限的用户访问。

复杂权限控制
这里将引入 SpEL （Spring Expression Language）表达式，它是 Spring 框架提供的一种动态表达式语言。基于 SpEL，只要该表达式的返回值是 true，那么 access()方法允许用户访问。例如下面的代码。

``` java
http.authorizeRequests().anyRequest().access("hasAuthority('CREATE')");
```

上述代码与使用 hasAuthority()方法的实现效果是完全一致的，但如果是更为复杂的场景，那么 access()方法的优势很明显。人们可以灵活创建一个表达式，然后通过 access()方法确定最后的结果，代码如下所示。

``` java
String expression = "hasAuthority('CREATE') and !hasAuthority('RETRIEVE')"; 

http.authorizeRequests().anyRequest().access(expression);
```

基于角色进行访问控制
同样也可以是使用access()方法内的SpringEL语言进行角色的控制
![[附件/Pasted image 20220916173503.png]]

## 使用配置方法控制访问权限
### 1.MVC 匹配器
``` java
http.authorizeRequests() 
    .mvcMatchers("/user").hasRole("USER") 
    .mvcMatchers("/admin").hasRole("ADMIN");
```
没有被 MVC 匹配器所匹配的端点，其访问过程不受任何限制

这种安全访问控制策略不太合理，更好的做法是让那些没有被 MVC 匹配器匹配的请求也需要进行认证之后才能访问，实现方式如下所示。
``` java
http.authorizeRequests() 
     .mvcMatchers("/user").hasRole("USER") 
     .mvcMatchers("/admin").hasRole("ADMIN");
     .anyRequest().authenticated();
```

如果一个 Controller 中存在两个路径完全一样的 HTTP 端点呢？这种情况是存在的。对 HTTP 端点而言，就算路径一样，只要所使用的 HTTP 方法不同，那就是不同的两个端点。针对这种情况，MVC 匹配器还提供了重载的 mvcMatchers()方法，如下所示。

``` java
mvcMatchers(HttpMethod method, String... patterns)
```

这个方法可以把 HTTP 方法作为一个访问的维度进行控制，如下所示。

```java
http.authorizeRequests() 
     .mvcMatchers(HttpMethod.POST, "/hello").authenticated() 
     .mvcMatchers(HttpMethod.GET, "/hello").permitAll() 
     .anyRequest().denyAll();
```

在上面这段配置代码中，如果一个 HTTP 请求使用 POST 方法访问「/hello」端点，那么需要进行认证；如果使用 GET 方法访问「/hello」端点则全部允许访问。最后，访问其余任一路径的所有请求都会被拒绝。

同时，如果想对某个路径下的所有子路径都指定同样的访问控制，在该路径后面添加「*」即可，如下所示。

```
http.authorizeRequests() 
    .mvcMatchers(HttpMethod.GET, "/user/*").authenticated(
```