Spring Securtiy中的角色和权限
![[附件/Pasted image 20220916164955.png]]GrantedAuthority 对象代表的就是一种权限对象，而一个 UserDetails 对象具备 1 个或多个 GrantedAuthority 对象。通过这种关联关系可以对用户的权限进行限制

简单的权限控制
-   hasAuthority（String）：允许具有特定权限的用户访问。
-   hasAnyAuthority（String）：允许具有任一权限的用户访问。

复杂权限控制
这里将引入 SpEL （Spring Expression Language）表达式，它是 Spring 框架提供的一种动态表达式语言。基于 SpEL，只要该表达式的返回值是 true，那么 access()方法允许用户访问。例如下面的代码。

``` java
http.authorizeRequests().anyRequest().access("hasAuthority('CREATE')");
```

上述代码与使用 hasAuthority()方法的实现效果是完全一致的，但如果是更为复杂的场景，那么 access()方法的优势很明显。人们可以灵活创建一个表达式，然后通过 access()方法确定最后的结果，代码如下所示。

``` java
String expression = "hasAuthority('CREATE') and !hasAuthority('RETRIEVE')"; 

http.authorizeRequests().anyRequest().access(expression);
```

基于角色进行访问控制
同样也可以是使用access()方法内的SpringEL语言进行角色的控制
![[附件/Pasted image 20220916173503.png]]

## 使用配置方法控制访问权限
### 1.MVC 匹配器
- 简单的角色匹配
``` java
http.authorizeRequests() 
    .mvcMatchers("/user").hasRole("USER") 
    .mvcMatchers("/admin").hasRole("ADMIN");
```
没有被 MVC 匹配器所匹配的端点，其访问过程不受任何限制
- 其他资源的匹配规则处理方案
这种安全访问控制策略不太合理，更好的做法是让那些没有被 MVC 匹配器匹配的请求也需要进行认证之后才能访问，实现方式如下所示。
``` java
http.authorizeRequests() 
     .mvcMatchers("/user").hasRole("USER") 
     .mvcMatchers("/admin").hasRole("ADMIN");
     .anyRequest().authenticated();
```
- 相同Http端点的处理
如果一个 Controller 中存在两个路径完全一样的 HTTP 端点呢？这种情况是存在的。对 HTTP 端点而言，就算路径一样，只要所使用的 HTTP 方法不同，那就是不同的两个端点。针对这种情况，MVC 匹配器还提供了重载的 mvcMatchers()方法，如下所示。

``` java
mvcMatchers(HttpMethod method, String... patterns)
```

这个方法可以把 HTTP 方法作为一个访问的维度进行控制，如下所示。

```java
http.authorizeRequests() 
     .mvcMatchers(HttpMethod.POST, "/hello").authenticated() 
     .mvcMatchers(HttpMethod.GET, "/hello").permitAll() 
     .anyRequest().denyAll();
```

在上面这段配置代码中，如果一个 HTTP 请求使用 POST 方法访问「/hello」端点，那么需要进行认证；如果使用 GET 方法访问「/hello」端点则全部允许访问。最后，访问其余任一路径的所有请求都会被拒绝。
- 子路径的匹配
同时，如果想对某个路径下的所有子路径都指定同样的访问控制，在该路径后面添加「*」即可，如下所示。

``` java
http.authorizeRequests() 
    .mvcMatchers(HttpMethod.GET, "/user/*").authenticated(
```

### 2.Ant 匹配器
-   antMatchers(String patterns)。
-   antMatchers(HttpMethod method)。
-   antMatchers(HttpMethod method, String patterns)。
Ant匹配器处理的地址末尾必须有/，但是MVC匹配器没有这个问题，不论请求地址的末尾是否有/。

### 3.正则表达式匹配器
-   regexMatchers(HttpMethod method, String regex)。
-   regexMatchers(String regex)。
优势：利用复杂的正则表达式对请求地址进行匹配。
``` java
http.authorizeRequests()
     .mvcMatchers("/email/{email:.*(.+@.+\\.com)}")
     .permitAll()
     .anyRequest()
     .denyAll();
```

可以看到，这段代码匹配了常见的邮箱地址，只有输入的请求中包含的是一个合法的邮箱地址才允许访问

## Spring Security 授权流程
Spring Security 实现对所有请求进行权限控制的配置方法只需要如下所示的一行代码即可。
``` java
http.authorizeRequests();
```
HTTP请求会经过一系列过滤器链
![[附件/Pasted image 20220917110442.png]]
 FilterSecurityInterceptor
 - 过滤器链的末端
 - 核心功能：在权限控制过程进行拦截，判定该请求能否访问目标 HTTP 端点。
 - 整个权限控制的第一个环节，称之为拦截请求。

 下一步为获取权限配置：
- 获取该请求的访问资源，以及访问这些资源所需要的权限信息。
- SecurityMetadataSource 接口，代表权限配置的抽象，其中保存一系列提供安全元数据的数据源。
``` java
http.authorizeRequests().anyRequest().hasAuthority("CREATE");
```

![[附件/Pasted image 20220917111219.png]]

## 拦截请求
FilterSecurityInterceptor实现了Servlet的filter，本质也是过滤器。
![[附件/Pasted image 20220917112922.png]]
其invoke()方法中调用了父类的beforeInvocation()方法
AbstractSecurityInterceptor 中的 beforeInvocation()方法
``` java
protected InterceptorStatusToken beforeInvocation（Object object） {

    …
    //获取 ConfigAttribute 集合 
    Collection< ConfigAttribute > attributes = this.obtainSecurityMetadataSource()
          .getAttributes（object）；

    …
    //获取认证信息 
    Authentication authenticated = authenticateIfRequired()；

    //执行授权 
    try {
        this.accessDecisionManager.decide(authenticated, object, attributes);
    }
    catch (AccessDeniedException accessDeniedException) {
        …
    }
    …
}
```
- 获取权限配置
public abstract SecurityMetadataSource obtainSecurityMetadataSource();
从SecurityMetadataSource获取的ConfigAttribute集合