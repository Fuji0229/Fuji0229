# 1. SDS

1.  简单动态字符串 -Simple Dynamic String 的作用
    
2.  存储String类型的底层数据结构
    
    2.也会用作缓存 （AOF的，客户端状态中的输入缓存区）
    
3.  定义：
    
    结构：sds.h/sdshdr
    
    struct sdshdr{
    
    //记录buf数组已使用字节长度
    
    int len; //记录buf数组未使用的字节长度
    
    int free;
    
    //字节数组
    
    char buf[];
    
    }
    
    字节数组保存字符串时，除了保存字符串的每一个字节的字符外，在字符串的末尾会多一个字节长度用于保存空字符串‘\0’。
    
    使用空字符串结尾方式，使得SDS也可以使用c中的字符串函数库的一部分函数。
    
4.  SDS与c字符串的区别
    
    1.**字符串长度的获取方式** SDS获取长度可以直接通过获取len属性获取，时间复杂度为O(1) c语言通过遍历字节数组获取长度 时间复杂度为O(n)
    
    1.  **防止缓冲区溢出**，SDS在字符串进行更改时会先判断字符串的长度，如果字节数组的长度不够，那么会先对字节数组进行扩容再保存字符串。 c语言在更改字符串时，如果未对原来的字符数组进行合理的空间分配，那么保存的字符串如果超过原来的字符数组的长度，并且在保存字符数组的空间处有相邻的数据，那么该字符数组的字符串将会溢出到相邻的空间并修改该区域的内容。
    2.  **减少修改字符串带来的内存重新分配**
    
    C语言内存分配的两种情况
    
    -   扩容，未重新分配就会内存溢出
    -   截取，未重新分配就会内存泄露
    
    SDS对于两种情况的处理
    
    -   （扩容）空间预分配 SDS进行空间扩展时，不仅会为SDS分配修改必须要的空间，还会为SDS分配额外的空间 分配方式 修改后小于1M，分配与len属性同样的未使用空间 修改后大于等于1M，将会分配1M的空间 修改后为30M的计算公式 30M + 1M + 1byte
    -   （截取）惰性空间释放
    
    字符串长度小于当前空间大小时，只会减少free的长度，但并未释放内存空间，当需要扩容时，如果惰性空间满足扩容条件，将不会进行内存上的扩容，而只修改free字段的值
    
    同时，SDS也提供了对应的api在需要时可以释放使用空间
    
    4.  **二进制安全**
    
    C字符串只保存文本，不能保存图片，音频、视频、压缩文件这样的二进制数据
    
    不能保存使用空字符串来分隔多个单词的特殊格式
    
    为了确保Redis在不同场景中的安全性，SDS所有的api都是二进制安全的（以二进制的方式处理SDS存放在buf字符数组中的数据）
    
    二进制保存的方式，使得Redis的存储的内容不仅仅局限于文本文件，同样适用于任意格式的二进制数据
    
    **5. 兼容部分C字符串函数**
    
    遵循c字符串以空字符串结尾的惯例，使得SDS可以重用部分c字符串函数
![[附件/c字符串和SDS的区别.png]]